/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef TICTOC_H_
#define TICTOC_H_

/*!
 * Forward declaration for the Tictoc state machine.
 */
 class Tictoc;


#include <deque>
#include "base/sc_types.h"
#include "base/sc_rxcpp.h"
#include "base/sc_statemachine.h"
#include "base/sc_timer.h"
#include "base/sc_tracing.h"

/*! \file Header of the state machine 'tictoc'.
*/


#ifndef SCT_EVENTS_TICTOC_H
#define SCT_EVENTS_TICTOC_H
#ifndef SC_INVALID_EVENT_VALUE
#define SC_INVALID_EVENT_VALUE 0
#endif

namespace tictoc_events
{
typedef enum  {
	invalid_event = SC_INVALID_EVENT_VALUE,
	toggle,
	tictoc_main_Idle_time_event_0,
	tictoc_main_Playing_time_event_0,
	tictoc_main_Playing_active_Tic_time_event_0,
	tictoc_main_Playing_active_Toc_time_event_0
} TictocEventName;

class SctEvent
{
	public:
		SctEvent(TictocEventName name) : name(name){}
		virtual ~SctEvent(){}
		const TictocEventName name;
		
};
		
template <typename T>
class TypedSctEvent : public SctEvent
{
	public:
		TypedSctEvent(TictocEventName name, T value) :
			SctEvent(name),
			value(value)
			{}
		virtual ~TypedSctEvent(){}
		const T value;
};

class SctEvent__toggle : public SctEvent
{
	public:
		SctEvent__toggle(TictocEventName name) : SctEvent(name){};
};
class TimedSctEvent : public SctEvent
{
	public:
		TimedSctEvent(TictocEventName name) : SctEvent(name){};
};

}
#endif /* SCT_EVENTS_TICTOC_H */



/*! Define indices of states in the StateConfVector */
#define SCVI_MAIN_IDLE 0
#define SCVI_MAIN_PLAYING 0
#define SCVI_MAIN_PLAYING_ACTIVE_TIC 0
#define SCVI_MAIN_PLAYING_ACTIVE_TOC 0

/*! Defines the standard value for the "no feature" id of the statechart feature enumerations */
#ifndef SC_NO_FEATURE
#define SC_NO_FEATURE 0
#endif



class Tictoc : public sc::timer::TimedInterface, public sc::StatemachineInterface
{
	public:
		Tictoc();
		
		virtual ~Tictoc();
		
		/*! Enumeration of all states */ 
		typedef enum
		{
			Tictoc_last_state,
			main_Idle,
			main_Playing,
			main_Playing_active_Tic,
			main_Playing_active_Toc
		} TictocStates;


		/*! Enumeration of all features of the statechart */
		typedef enum
		{
			no_feature = SC_NO_FEATURE,
			toggle_feature,
			tic_feature,
			toc_feature,
			count_feature,
			delay_feature,
			x_feature,
			b_feature,
			foo_y_feature,
			internal_i_feature
		} TictocFeature;

		static const sc_integer numStates = 4;
		
		/*! Raises the in event 'toggle' that is defined in the default interface scope. */
		void raiseToggle();
		
		/*! Gets the observable of the out event 'tic' that is defined in the default interface scope. */
		sc::rx::Observable<void>* getTic();
		
		/*! Gets the observable of the out event 'toc' that is defined in the default interface scope. */
		sc::rx::Observable<void>* getToc();
		
		/*! Gets the value of the variable 'count' that is defined in the default interface scope. */
		sc_integer getCount() const;
		
		/*! Sets the value of the variable 'count' that is defined in the default interface scope. */
		void setCount(sc_integer value);
		
		/*! Gets the value of the variable 'delay' that is defined in the default interface scope. */
		sc_integer getDelay() const;
		
		/*! Sets the value of the variable 'delay' that is defined in the default interface scope. */
		void setDelay(sc_integer value);
		
		/*! Gets the value of the variable 'x' that is defined in the default interface scope. */
		sc_integer getX() const;
		
		/*! Sets the value of the variable 'x' that is defined in the default interface scope. */
		void setX(sc_integer value);
		
		/*! Gets the value of the variable 'b' that is defined in the default interface scope. */
		sc_boolean getB() const;
		
		/*! Sets the value of the variable 'b' that is defined in the default interface scope. */
		void setB(sc_boolean value);
		
		//! Inner class for foo interface scope.
		class Foo
		{
			public:
				Foo(Tictoc* parent);
				
				/*! Gets the value of the variable 'y' that is defined in the interface scope 'foo'. */
				sc_integer getY() const;
				
				/*! Sets the value of the variable 'y' that is defined in the interface scope 'foo'. */
				void setY(sc_integer value);
				
				
				
				
			private:
				friend class Tictoc;
				
				sc_integer y;
				void dispatch_event(tictoc_events::SctEvent * event);
				
				Tictoc* parent;
				
				
				
				
				
		};
		
		/*! Returns an instance of the interface class 'Foo'. */
		Foo* foo();
		
		
		/*
		 * Functions inherited from StatemachineInterface
		 */
		virtual void enter();
		
		virtual void exit();
		
		/*!
		 * Checks if the state machine is active (until 2.4.1 this method was used for states).
		 * A state machine is active if it has been entered. It is inactive if it has not been entered at all or if it has been exited.
		 */
		virtual sc_boolean isActive() const;
		
		
		/*!
		* Checks if all active states are final. 
		* If there are no active states then the state machine is considered being inactive. In this case this method returns false.
		*/
		virtual sc_boolean isFinal() const;
		
		/*! 
		 * Checks if member of the state machine must be set. For example an operation callback.
		 */
		sc_boolean check();
		
		/*
		 * Functions inherited from TimedStatemachineInterface
		 */
		virtual void setTimerService(sc::timer::TimerServiceInterface* timerService);
		
		virtual sc::timer::TimerServiceInterface* getTimerService();
		
		virtual void raiseTimeEvent(sc_eventid event);
		
		virtual sc_integer getNumberOfParallelTimeEvents();
		
		
		
		/*! Checks if the specified state is active (until 2.4.1 the used method for states was calles isActive()). */
		sc_boolean isStateActive(TictocStates state) const;
		
		//! number of time events used by the state machine.
		static const sc_integer timeEventsCount = 4;
		
		//! number of time events that can be active at once.
		static const sc_integer parallelTimeEventsCount = 2;
		
		
		/*! Gets the observable for generic trace events. Trace observers can subscribe. */
		sc::rx::Observable<sc::tracing::TraceEvent>* getTrace();



	protected:
		
		
	private:
		Tictoc(const Tictoc &rhs);
		Tictoc& operator=(const Tictoc&);
		
		/*! Raises the in event 'toggle' that is defined in the default interface scope. */
		void internal_raiseToggle();
		sc_boolean toggle_raised;
		sc::rx::Observable<void> tic_observable;
		sc_boolean tic_raised;
		sc::rx::Observable<void> toc_observable;
		sc_boolean toc_raised;
		sc_integer count;
		sc_integer delay;
		sc_integer x;
		sc_boolean b;
		void iface_dispatch_event(tictoc_events::SctEvent * event);
		
		sc_real i;
		void internal_dispatch_event(tictoc_events::SctEvent * event);
		
		
		//! the maximum number of orthogonal states defines the dimension of the state configuration vector.
		static const sc_ushort maxOrthogonalStates = 1;
		
		sc::timer::TimerServiceInterface* timerService;
		sc_boolean timeEvents[timeEventsCount];
		
		
		TictocStates stateConfVector[maxOrthogonalStates];
		
		sc_ushort stateConfVectorPosition;
		
		Foo ifaceFoo;
		
		
		sc_boolean isExecuting;
		

		/*! Gets the value of the variable 'i' that is defined in the internal scope. */
		sc_real getI() const;
		
		/*! Sets the value of the variable 'i' that is defined in the internal scope. */
		void setI(sc_real value);
		
		
		// prototypes of all internal functions
		
		void enact_main_Idle();
		void enact_main_Playing();
		void enact_main_Playing_active_Tic();
		void enact_main_Playing_active_Toc();
		void exact_main_Idle();
		void exact_main_Playing();
		void exact_main_Playing_active_Tic();
		void exact_main_Playing_active_Toc();
		void enseq_main_Idle_default();
		void enseq_main_Playing_default();
		void enseq_main_Playing_active_Tic_default();
		void enseq_main_Playing_active_Toc_default();
		void enseq_main_default();
		void enseq_main_Playing_active_default();
		void exseq_main_Idle();
		void exseq_main_Playing();
		void exseq_main_Playing_active_Tic();
		void exseq_main_Playing_active_Toc();
		void exseq_main();
		void exseq_main_Playing_active();
		void react_main__entry_Default();
		void react_main_Playing_active__entry_Default();
		sc_boolean react();
		sc_boolean main_Idle_react(const sc_boolean try_transition);
		sc_boolean main_Playing_react(const sc_boolean try_transition);
		sc_boolean main_Playing_active_Tic_react(const sc_boolean try_transition);
		sc_boolean main_Playing_active_Toc_react(const sc_boolean try_transition);
		void clearInEvents();
		void runCycle();
		
		
		tictoc_events::SctEvent* getNextEvent();
		void dispatch_event(tictoc_events::SctEvent * event);
		tictoc_events::TictocEventName getTimedEventName(sc_eventid evid);
		std::deque<tictoc_events::SctEvent*> inEventQueue;
		
		
		sc::rx::Observable<sc::tracing::TraceEvent> trace_observable;
		void trace(sc::tracing::TraceEventType type, sc_integer id, const void* value);

};




#endif /* TICTOC_H_ */
