/** Generated by YAKINDU Statechart Tools code generator. */

#ifndef YET_H_
#define YET_H_

#include <string>
#include "sc_types.h"
#include "sc_rxcpp.h"

#define YET_MESSAGE_INIT_BEGIN '%'
#define YET_MESSAGE_UPDATE_BEGIN '#'
#define YET_MESSAGE_SEPARATOR ','
#define YET_ERR_INVALID_MSG 1
#define YET_ERR_INVALID_BEGIN 2
#define YET_ERR_INVALID_TIMESTAMP 4
#define YET_ERR_INVALID_KEY 8
#define YET_ERR_INVALID_VALUE 16
#define YET_ERR_MISSING_VALUE 32
#define YET_ERR_NULLPTR 64

#ifndef YET_SCOPE_SEND_BUF_LEN
#define YET_SCOPE_SEND_BUF_LEN 255
#endif

namespace yet {

enum MessageType {
	INIT,
	UPDATE
};

typedef uint64_t yet_timestamp;
typedef size_t yet_msize;
typedef uint16_t yet_error;


class Message {

	public:
		Message();
		virtual ~Message();

		enum MessageType type;
		yet_timestamp timestamp;
		std::string key;
		std::string value;

		yet_msize lenght();
};


class Scope {
	public:
		Scope();
		virtual ~Scope();

		Scope *parent;
		Scope **child_scopes;
		sc_integer num_child_scopes;
		std::string name;
		void* instance;



		sc_observable_sc_string trace_messages;

		virtual yet_error handle(Message &msg, std::string fqn) = 0;

		/*
		 * This function is called by tracing state machines.
		 */
		virtual void send(Message &msg);

		/*!
		 * If a message was received, call this function to process it.
		 */
		virtual void accept_message(char *text);

		virtual void dispatch_message(Message* msg, char *fqn);

		virtual char* create_message(char* msg, char* dst, sc_boolean meta);

		virtual void yet_scope_init(Scope &parent_scope, std::string name, yet_handler handler, void* instance);

	protected:


		class MessageObserver : public sc::rx::SingleSubscriptionObserver<std::string>
		{
			public:
				MessageObserver(Scope &s) :
					SingleSubscriptionObserver(),
					scope(s)
				{}

				virtual ~MessageObserver() {}

				virtual void next() {
					this->scope.accept_message(text);
				}

				Scope& scope;


		};

		MessageObserver message_receiver;


};

} // namespace yet



#endif /* YET_H_ */
